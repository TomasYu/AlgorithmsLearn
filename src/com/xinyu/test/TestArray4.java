package com.xinyu.test;

/**
 * Created by zy on 2019/4/2.
 */
public class TestArray4 {
    public static void main(String[] args) {
    char[][] board = new char[][]{
      {'5','3','.','.','7','.','.','.','.'},
      {'6','.','.','1','9','5','.','.','.'},
      {'.','9','8','.','.','.','.','6','.'},
      {'8','.','.','.','6','.','.','.','3'},
      {'4','.','.','8','.','3','.','.','1'},
      {'7','.','.','.','2','.','.','.','6'},
      {'.','6','.','.','.','.','2','8','.'},
      {'.','.','.','4','1','9','.','.','5'},
      {'.','.','.','.','8','.','.','7','9'}

//        {'5','3','.','.','7','.','.','.','.'},
//        {'6','.','.','1','9','5','.','.','.'},
//        {'.','9','8','.','.','.','.','6','.'},
//        {'8','.','.','.','6','.','.','.','3'},
//        {'4','.','.','8','.','3','.','.','1'},
//        {'7','.','.','.','2','.','.','.','6'},
//        {'.','6','.','.','.','.','2','8','.'},
//        {'.','.','.','4','1','9','.','.','5'},
//        {'.','.','.','.','8','.','.','7','9'}
//            {'.','.','.','.','5','.','.','1','.'},
//            {'.','4','.','3','.','.','.','.','.'},
//            {'4','.','.','.','.','.','.','.','.'},
//            {'8','.','.','.','.','.','.','2','.'},
//            {'.','.','2','.','7','.','.','.','.'},
//            {'.','1','5','.','.','.','.','.','.'},
//            {'.','.','.','.','.','2','.','.','.'},
//            {'.','2','.','9','.','.','.','.','.'},
//            {'.','.','4','.','.','.','.','.','.'}

//{'.','.','5','.','.','.','.','.','.'},
//{'.','.','.','8','.','.','.','3','.'},
//{'.','5','.','.','2','.','.','.','.'},
//{'.','.','.','.','.','.','.','.','.'},
//{'.','.','.','.','.','.','.','.','9'},
//{'.','.','.','.','.','.','4','.','.'},
//{'.','.','.','.','.','.','.','.','7'},
//{'.','1','.','.','.','.','.','.','.'},
//{'2','4','.','.','.','.','9','.','.'}
    
    };
        System.out.println(isValidSudoku(board));

    }

    /**
     * 判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。

     数字 1-9 在每一行只能出现一次。
     数字 1-9 在每一列只能出现一次。
     数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。
     数独部分空格内已填入了数字，空白格用 '.' 表示。
     说明:

     一个有效的数独（部分已被填充）不一定是可解的。
     只需要根据以上规则，验证已经填入的数字是否有效即可。
     给定数独序列只包含数字 1-9 和字符 '.' 。
     给定数独永远是 9x9 形式的。
     * @param board
     * @return
     */
    public static boolean isValidSudoku(char[][] board) {
        /**
         * i 表示第几行 j 表示第几列
         */
//        char curChar;
//        int rectI;
//        int rectJ;
//        for (int i = 0; i < 9 ; i++) {
//            for (int j = 0; j<9 ; j++ ){
//                curChar = board[i][j];
//                //如果是空的  不管
//                if(curChar == '.'){
//                    continue;
//                }
//                //保证横排没有重复的元素
//                for (int k = j+1; k < board[i].length; k++) {
//                    if (curChar == board[i][k]) {
//                        return false;
//                    }
//                }
//                //保证竖排没有重复的元素
//                for (int k = i+1; k < board.length ; k++) {
//                    if (curChar == board[k][j]) {
//                        return false;
//                    }
//                }
//
//                //保证在一个矩阵里面没有重复的元素
//                // 得出当前元素在第几个矩阵
//                rectI = i/3;
//                rectJ = j/3;
//
//                for (int rectStartI = rectI*3;rectStartI < rectI*3+3;rectStartI++){
//                    for (int rectStartJ = rectJ*3; rectStartJ < rectJ*3 + 3; rectStartJ++) {
//                        //如果是当前的元素  则忽略 下一个
//                        if (rectStartI == i && rectStartJ ==j) {
//                            continue;
//                        }
//                        if (curChar == board[rectStartI][rectStartJ]) {
//                            return false;
//                        }
//                    }
//                }
//            }
//        }
//        return true;


        /*网上算法：
        *
        * 很简洁  而且没有重复的循环 很棒
        * */
        for(int i = 0; i < 9; i++){
            for(int j = 0; j < 9; j++){
                if(board[i][j] == '.')continue;
                for(int k = 8; k > j; k-- )
                    if(board[i][j] == board[i][k])
                        return false;
                for(int k = 8; k > i; k--)
                    if(board[i][j] == board[k][j])
                        return false;
                for(int k = i + 1; k % 3 != 0; k ++){
                    for(int h = j /3 *3;h < j / 3 *3 + 3; h ++ )
                        if(board[i][j] == board[k][h])
                            return false;
                }
            }
        }
        return true;

    }
}
